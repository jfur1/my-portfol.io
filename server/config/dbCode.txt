// PostgreSQL Command to Connect to AWS:
psql --host=mp-identifier.cyxo9dxpukfl.us-east-2.rds.amazonaws.com --port=5432 --username=postgres --password --dbname=mpdb


CREATE TABLE IF NOT EXISTS users (
  user_id INT NOT NULL,
  first_name VARCHAR(45) NOT NULL,
  last_name VARCHAR(45) NOT NULL,
  username VARCHAR(32) NOT NULL,
  email VARCHAR(64) NOT NULL,
  password VARCHAR(64) NOT NULL,
  PRIMARY KEY (user_id)
);

// Insert Test Data
INSERT INTO users(user_id, first_name, last_name, username, email, password)
    VALUES(1,'Joe',  'Jackson', '@jo3', 'joe.jackson@gmail.com', 'jackjoe123'),
    (2,'Sarah', 'Marcus', '@sarahM123', 'Sar.Mar@gmail.com', 'SMAR321'),
    (3,'Evan', 'Samson', '@evsa', 'evsa7039@colorado.edu', 'smevans1598'),
    (4,'Sawyer', 'Mack', '@smackThat', 'Smack.backup@gmail.com', 'prez1234'),
    (5,'Alan', 'Warder', '@warderA', 'alan.mailbox@gmail.com', 'gobuffs'),
    (6,'Fred', 'Frankerson', '@freddyF', 'franky.frank@hotmail.com', 'frankrules');


CREATE TABLE IF NOT EXISTS profile (
  profile_id INT NOT NULL,
  user_id INT NOT NULL,
  bio VARCHAR(240) NULL,
  links VARCHAR(500) NULL,
  city VARCHAR(45) NULL,
  state VARCHAR(45) NULL,
  country VARCHAR(45) NULL,
  date_registered DATE NOT NULL DEFAULT CURRENT_DATE,
  PRIMARY KEY (profile_id, user_id),
  CONSTRAINT fk_profile_user
    foreign key(user_id)
    REFERENCES users (user_id)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION
);

// Not scalable in the long run, but allows users to have more than one account 
// Helps resolve future headaches for creating groups/events

// Insert Test Data
INSERT INTO profile(profile_id, user_id, bio, links, city, state, country)
  VALUES(1, 1, 'I love football', '', 'Dallas', 'TX', ''),
  (2, 2, 'Biographies give me anxiety', 'https://my-portfol.io', 'Boulder', 'CO', 'USA'),
  (3, 3, 'Made you look!', 'https://google.com/images/cats', 'New York', 'NY', '');

// Test Query: What is the email of the most recently created profile?
SELECT email FROM users WHERE user_id=(
  SELECT MAX(profile_id) FROM profile
);


CREATE TABLE IF NOT EXISTS post (
  post_id INT NOT NULL,
  profile_id INT NOT NULL,
  post_date DATE NOT NULL DEFAULT CURRENT_DATE,
  tags VARCHAR(64) NULL,
  content VARCHAR(240) NOT NULL,
  other_details VARCHAR(64) NULL,
  PRIMARY KEY(post_id)
);

// Insert Test Data
INSERT INTO post(post_id, profile_id, tags, content, other_details)
  VALUES(1, 2, '#test', 'Sarah here! Testing the content of my post!', 'I like cats'),
  (2, 1, '', 'Why I hate my name, Sawyer', ''),
  (3, 3, '#playoffs', 'Anyone see the game last night?', '');

// Test Query: Get the email of anyone who used the tag '#playoffs
SELECT email FROM users WHERE user_id = (
  SELECT profile_id FROM profile WHERE profile_id=(
    SELECT profile_id FROM post WHERE tags='#playoffs'
  )
);


----------------------------------- WAIT TO ADD THESE TABLES -----------------------------

*/
CREATE TABLE users (
  id         INT PRIMARY KEY,
  username   VARCHAR(32) NOT NULL UNIQUE
);

/* We'd like to track followers - each user can track other users and can be
   tracked by other users at the same time. That means we're talking about 
   many-to-many relationship and the correct way to represent this in a
   normalized database is a junction table.
   Every user can track each other user only once (he either tracks him or not,
   tracking twice does not make sense and it would cause some strange issues).


*/
CREATE TABLE followers (
  followed_id   INT REFERENCES users(id),
  follower_id   INT REFERENCES users(id),
  PRIMARY KEY (followed_id, follower_id)
);

CREATE INDEX follower_idx ON followers(follower_id);

/* That's all we need for tracking users and followers, so let's create three 
   users (A, B and C) and then define some followers. */
INSERT INTO users VALUES (1, 'A');
INSERT INTO users VALUES (2, 'B');
INSERT INTO users VALUES (3, 'C');

/* Now let's define that user A follows both B and C. */
INSERT INTO followers VALUES (2,1);
INSERT INTO followers VALUES (3,1);

/* And user C follows user B. */
INSERT INTO followers VALUES (2,3);

/* That means B is followed both by A and C but does not follow anyone. So let's
   play with the followers a bit ... */

/* Let's display A's followers first (no one follows A) */
SELECT u.* FROM users u JOIN followers f ON (f.follower_id = u.id)
WHERE followed_id = 1;

/* Now let's see who follows B (should be both A and C) */
SELECT u.* FROM users u JOIN followers f ON (f.follower_id = u.id)
WHERE followed_id = 2;

/* And finallyu let's see who follows C (should be A only) */
SELECT u.* FROM users u JOIN followers f ON (f.follower_id = u.id)
WHERE followed_id = 3;

/* Now we can do a bit of social analysis, and see who's followed both by A and C.
   As expected, it's B. */
SELECT u.* FROM users u JOIN followers f ON (f.followed_id = u.id)
WHERE follower_id = 1
  INTERSECT
SELECT u.* FROM users u JOIN followers f ON (f.followed_id = u.id)
WHERE follower_id = 3;

/* And now let's see who is not followed back by C, i.e. who follows C but C does
   not follow him? Obviously it has to be B, because C follows only B. */
SELECT u.* FROM users u JOIN followers f ON (f.followed_id = u.id)
WHERE follower_id = 3
  EXCEPT
SELECT u.* FROM users u JOIN followers f ON (f.follower_id = u.id)
WHERE followed_id = 3;