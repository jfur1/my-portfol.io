// PostgreSQL Command to Connect to AWS:
psql --host=mp-identifier.cyxo9dxpukfl.us-east-2.rds.amazonaws.com --port=5432 --username=postgres --password --dbname=mpdb


CREATE TABLE IF NOT EXISTS users (
  user_id INT NOT NULL,
  first_name VARCHAR(45) NOT NULL,
  last_name VARCHAR(45) NOT NULL,
  username VARCHAR(32) NOT NULL,
  email VARCHAR(64) NOT NULL,
  password VARCHAR(64) NOT NULL,
  PRIMARY KEY (user_id)
);

// Insert Test Data
INSERT INTO users(user_id, first_name, last_name, username, email, password)
    VALUES(1,'Joe',  'Jackson', '@jo3', 'joe.jackson@gmail.com', 'jackjoe123'),
    (2,'Sarah', 'Marcus', '@sarahM123', 'Sar.Mar@gmail.com', 'SMAR321'),
    (3,'Evan', 'Samson', '@evsa', 'evsa7039@colorado.edu', 'smevans1598'),
    (4,'Sawyer', 'Mack', '@smackThat', 'Smack.backup@gmail.com', 'prez1234'),
    (5,'Alan', 'Warder', '@warderA', 'alan.mailbox@gmail.com', 'gobuffs'),
    (6,'Fred', 'Frankerson', '@freddyF', 'franky.frank@hotmail.com', 'frankrules');

CREATE TABLE IF NOT EXISTS post (
  pid INT NOT NULL PRIMARY KEY,
  body VARCHAR CONSTRAINT tbl_col_len CHECK (length(body) < 240),
  uid INT REFERENCES users(user_id),
  author VARCHAR REFERENCES users(username),
  date_created DATE NOT NULL DEFAULT CURRENT_DATE,
  like_user_id INT[] DEFAULT ARRAY[]::INT[],
  likes INT DEFAULT 0
);

INSERT INTO post(pid, body, uid, author)
VALUES(1, 'This is an example of a body for a post! We don''t need to insert post_id because they are auto incremented by postgres!', 8, '@dopamine'),
(2, 'I love football so much!', 7, 'tristanhanna');

--------------------------------------------------------------------

CREATE TABLE IF NOT EXISTS profile(
  profile_id INT NOT NULL PRIMARY KEY,
  uid INT REFERENCES users(user_id),
  bio VARCHAR,
  location VARCHAR(64)
);

INSERT INTO profile(profile_id, uid, bio, location)
VALUES(1, 8, 'bios give me anxiety', 'Boulder, CO'),
(2, 7, 'I love football!', 'Denver, CO'),
(3, 4, 'I don''t know what to put here :(', NULL);

--------------------------------------------------------------------

CREATE TABLE IF NOT EXISTS hobbies(
  hobby_id INT NOT NULL PRIMARY KEY,
  uid INT REFERENCES users(user_id),
  hobby VARCHAR(64) NOT NULL
);

INSERT INTO hobbies(hobby_id, uid, hobby)
VALUES(1, 8, 'Skateboarding'),
(2, 7, 'Running'),
(3, 8, 'Snowboarding'),
(4, 7, 'Watching football'),
(5, 4, 'Long walks on the beach');

--------------------------------------------------------------------

CREATE TABLE IF NOT EXISTS skills(
  skill_id INT NOT NULL PRIMARY KEY,
  uid INT REFERENCES users(user_id),
  skill VARCHAR(64) NOT NULL
);

INSERT INTO skills(skill_id, uid, skill)
VALUES(1, 8, 'Fast Learner'),
(2, 7, 'React.js'),
(3, 8, 'Interpersonal Communication'),
(4, 7, 'Team Player');

--------------------------------------------------------------------

CREATE TABLE IF NOT EXISTS links(
  link_id INT NOT NULL PRIMARY KEY,
  uid INT REFERENCES users(user_id),
  link VARCHAR(255) NOT NULL
);

INSERT INTO links(link_id, uid, link)
VALUES(1, 8, 'https://github.com/jfur1'),
(2, 7, 'https://github.com/tristanhanna'),
(3, 4, 'www.google.com'),
(4, 8, 'http://jfur1.github.io/sorting-visualizer/'),
(5, 7, 'https://www.tristanhanna.com/');

--------------------------------------------------------------------

CREATE TABLE IF NOT EXISTS education(
  education_id INT NOT NULL PRIMARY KEY,
  uid INT REFERENCES users(user_id),
  organization VARCHAR(255),
  education VARCHAR(255) NOT NULL,
  from_when DATE,
  to_when DATE
);

INSERT INTO education(education_id, uid, organization, education, from_when, to_when)
VALUES(1, 8, 'University of Colorado Boulder', 'B.A. Computer Science', '2016-07-01', '2020-12-23'),
(2, 7, 'University of Colorado Boulder', 'T.A.M.', '2016-07-01', '2020-05-01'),
(3, 8, NULL, 'Google I.T. Support Certification', NULL, NULL),
(4, 7, NULL, 'C.P.R. Certified', NULL, NULL);

--------------------------------------------------------------------

CREATE TABLE IF NOT EXISTS portfolio(
  portfolio_id INT NOT NULL PRIMARY KEY,
  uid INT REFERENCES users(user_id),
  occupation VARCHAR(255) NOT NULL,
  organization VARCHAR(255),
  from_when DATE,
  to_when DATE
);

INSERT INTO portfolio(portfolio_id, uid, occupation, organization, from_when, to_when)
VALUES(1, 8, 'Server', 'Eureka!', '2019-09-01', '2020-04-01'),
(2, 7, 'Front End Web Development', 'Google', '2016-05-01', '2018-03-01'),
(3, 8, 'Line Cook', 'Dilly''s Restaurant', '2013-05-01', '2016-04-01'),
(4, 7, 'Full Stack Web Developer', 'Google', '2016-05-01', '2020-04-01');





----------------------------------- WAIT TO ADD THESE TABLES -----------------------------
from: https://www.freecodecamp.org/news/fullstack-react-blog-app-with-express-and-psql/

CREATE TABLE users (
  uid SERIAL PRIMARY KEY,
  username VARCHAR(255) UNIQUE,
  email VARCHAR(255),
  email_verified BOOLEAN,
  date_created DATE,
  last_login DATE
);

CREATE TABLE IF NOT EXISTS post (
  pid SERIAL PRIMARY KEY,
  body VARCHAR(240),
  uid INT REFERENCES users(user_id),
  author VARCHAR REFERENCES users(username),
  date_created TIMESTAMP,
  like_user_id INT[] DEFAULT ARRAY[]::INT[],
  likes INT DEFAULT 0
);

CREATE TABLE comments (
  cid SERIAL PRIMARY KEY,
  comment VARCHAR(255),
  author VARCHAR REFERENCES users(username),
  user_id INT REFERENCES users(uid),
  post_id INT REFERENCES posts(pid),
  date_created TIMESTAMP
);
-------------------------------------------------------------------

*/
CREATE TABLE users (
  id         INT PRIMARY KEY,
  username   VARCHAR(32) NOT NULL UNIQUE
);

/* We'd like to track followers - each user can track other users and can be
   tracked by other users at the same time. That means we're talking about 
   many-to-many relationship and the correct way to represent this in a
   normalized database is a junction table.
   Every user can track each other user only once (he either tracks him or not,
   tracking twice does not make sense and it would cause some strange issues).


*/
CREATE TABLE followers (
  followed_id   INT REFERENCES users(id),
  follower_id   INT REFERENCES users(id),
  PRIMARY KEY (followed_id, follower_id)
);

CREATE INDEX follower_idx ON followers(follower_id);

/* That's all we need for tracking users and followers, so let's create three 
   users (A, B and C) and then define some followers. */
INSERT INTO users VALUES (1, 'A');
INSERT INTO users VALUES (2, 'B');
INSERT INTO users VALUES (3, 'C');

/* Now let's define that user A follows both B and C. */
INSERT INTO followers VALUES (2,1);
INSERT INTO followers VALUES (3,1);

/* And user C follows user B. */
INSERT INTO followers VALUES (2,3);

/* That means B is followed both by A and C but does not follow anyone. So let's
   play with the followers a bit ... */

/* Let's display A's followers first (no one follows A) */
SELECT u.* FROM users u JOIN followers f ON (f.follower_id = u.id)
WHERE followed_id = 1;

/* Now let's see who follows B (should be both A and C) */
SELECT u.* FROM users u JOIN followers f ON (f.follower_id = u.id)
WHERE followed_id = 2;

/* And finallyu let's see who follows C (should be A only) */
SELECT u.* FROM users u JOIN followers f ON (f.follower_id = u.id)
WHERE followed_id = 3;

/* Now we can do a bit of social analysis, and see who's followed both by A and C.
   As expected, it's B. */
SELECT u.* FROM users u JOIN followers f ON (f.followed_id = u.id)
WHERE follower_id = 1
  INTERSECT
SELECT u.* FROM users u JOIN followers f ON (f.followed_id = u.id)
WHERE follower_id = 3;

/* And now let's see who is not followed back by C, i.e. who follows C but C does
   not follow him? Obviously it has to be B, because C follows only B. */
SELECT u.* FROM users u JOIN followers f ON (f.followed_id = u.id)
WHERE follower_id = 3
  EXCEPT
SELECT u.* FROM users u JOIN followers f ON (f.follower_id = u.id)
WHERE followed_id = 3;