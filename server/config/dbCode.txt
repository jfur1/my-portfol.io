// PostgreSQL Command to Connect to AWS:
psql --host=mp-identifier.cyxo9dxpukfl.us-east-2.rds.amazonaws.com --port=5432 --username=postgres --password --dbname=mpdb


CREATE TABLE IF NOT EXISTS users (
  user_id INT NOT NULL,
  first_name VARCHAR(45) NOT NULL,
  last_name VARCHAR(45) NOT NULL,
  username VARCHAR(32) NOT NULL,
  email VARCHAR(64) NOT NULL,
  password VARCHAR(64) NOT NULL,
  PRIMARY KEY (user_id)
);

// Insert Test Data
INSERT INTO users(user_id, first_name, last_name, username, email, password)
    VALUES(1,'Joe',  'Jackson', '@jo3', 'joe.jackson@gmail.com', 'jackjoe123'),
    (2,'Sarah', 'Marcus', '@sarahM123', 'Sar.Mar@gmail.com', 'SMAR321'),
    (3,'Evan', 'Samson', '@evsa', 'evsa7039@colorado.edu', 'smevans1598'),
    (4,'Sawyer', 'Mack', '@smackThat', 'Smack.backup@gmail.com', 'prez1234'),
    (5,'Alan', 'Warder', '@warderA', 'alan.mailbox@gmail.com', 'gobuffs'),
    (6,'Fred', 'Frankerson', '@freddyF', 'franky.frank@hotmail.com', 'frankrules');

CREATE TABLE IF NOT EXISTS post (
  pid SERIAL PRIMARY KEY,
  body VARCHAR CONSTRAINT tbl_col_len CHECK (length(body) < 240),
  uid INT REFERENCES users(user_id),
  author VARCHAR REFERENCES users(username),
  date_created DATE NOT NULL DEFAULT CURRENT_DATE,
  like_user_id INT[] DEFAULT ARRAY[]::INT[],
  likes INT DEFAULT 0
);

INSERT INTO post(body, uid, author)
VALUES('This is an example of a body for a post! We don''t need to insert post_id because they are auto incremented by postgres!', 8, '@dopamine'),
('I love football so much!', 7, 'tristanhanna');


CREATE TABLE IF NOT EXISTS profile (
  profile_id INT NOT NULL,
  user_id INT NOT NULL,
  bio VARCHAR(240) NULL,
  links VARCHAR(500) NULL,
  city VARCHAR(45) NULL,
  state VARCHAR(45) NULL,
  country VARCHAR(45) NULL,
  date_registered DATE NOT NULL DEFAULT CURRENT_DATE,
  PRIMARY KEY (profile_id, user_id),
  CONSTRAINT fk_profile_user
    foreign key(user_id)
    REFERENCES users (user_id)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION
);

// Not scalable in the long run, but allows users to have more than one account 
// Helps resolve future headaches for creating groups/events

// Insert Test Data
INSERT INTO profile(profile_id, user_id, bio, links, city, state, country)
  VALUES(1, 1, 'I love football', '', 'Dallas', 'TX', ''),
  (2, 2, 'Biographies give me anxiety', 'https://my-portfol.io', 'Boulder', 'CO', 'USA'),
  (3, 3, 'Made you look!', 'https://google.com/images/cats', 'New York', 'NY', '');

// Test Query: What is the email of the most recently created profile?
SELECT email FROM users WHERE user_id=(
  SELECT MAX(profile_id) FROM profile
);



----------------------------------- WAIT TO ADD THESE TABLES -----------------------------
from: https://www.freecodecamp.org/news/fullstack-react-blog-app-with-express-and-psql/

CREATE TABLE users (
  uid SERIAL PRIMARY KEY,
  username VARCHAR(255) UNIQUE,
  email VARCHAR(255),
  email_verified BOOLEAN,
  date_created DATE,
  last_login DATE
);

CREATE TABLE IF NOT EXISTS post (
  pid SERIAL PRIMARY KEY,
  body VARCHAR(240),
  uid INT REFERENCES users(user_id),
  author VARCHAR REFERENCES users(username),
  date_created TIMESTAMP,
  like_user_id INT[] DEFAULT ARRAY[]::INT[],
  likes INT DEFAULT 0
);

CREATE TABLE comments (
  cid SERIAL PRIMARY KEY,
  comment VARCHAR(255),
  author VARCHAR REFERENCES users(username),
  user_id INT REFERENCES users(uid),
  post_id INT REFERENCES posts(pid),
  date_created TIMESTAMP
);
-------------------------------------------------------------------

*/
CREATE TABLE users (
  id         INT PRIMARY KEY,
  username   VARCHAR(32) NOT NULL UNIQUE
);

/* We'd like to track followers - each user can track other users and can be
   tracked by other users at the same time. That means we're talking about 
   many-to-many relationship and the correct way to represent this in a
   normalized database is a junction table.
   Every user can track each other user only once (he either tracks him or not,
   tracking twice does not make sense and it would cause some strange issues).


*/
CREATE TABLE followers (
  followed_id   INT REFERENCES users(id),
  follower_id   INT REFERENCES users(id),
  PRIMARY KEY (followed_id, follower_id)
);

CREATE INDEX follower_idx ON followers(follower_id);

/* That's all we need for tracking users and followers, so let's create three 
   users (A, B and C) and then define some followers. */
INSERT INTO users VALUES (1, 'A');
INSERT INTO users VALUES (2, 'B');
INSERT INTO users VALUES (3, 'C');

/* Now let's define that user A follows both B and C. */
INSERT INTO followers VALUES (2,1);
INSERT INTO followers VALUES (3,1);

/* And user C follows user B. */
INSERT INTO followers VALUES (2,3);

/* That means B is followed both by A and C but does not follow anyone. So let's
   play with the followers a bit ... */

/* Let's display A's followers first (no one follows A) */
SELECT u.* FROM users u JOIN followers f ON (f.follower_id = u.id)
WHERE followed_id = 1;

/* Now let's see who follows B (should be both A and C) */
SELECT u.* FROM users u JOIN followers f ON (f.follower_id = u.id)
WHERE followed_id = 2;

/* And finallyu let's see who follows C (should be A only) */
SELECT u.* FROM users u JOIN followers f ON (f.follower_id = u.id)
WHERE followed_id = 3;

/* Now we can do a bit of social analysis, and see who's followed both by A and C.
   As expected, it's B. */
SELECT u.* FROM users u JOIN followers f ON (f.followed_id = u.id)
WHERE follower_id = 1
  INTERSECT
SELECT u.* FROM users u JOIN followers f ON (f.followed_id = u.id)
WHERE follower_id = 3;

/* And now let's see who is not followed back by C, i.e. who follows C but C does
   not follow him? Obviously it has to be B, because C follows only B. */
SELECT u.* FROM users u JOIN followers f ON (f.followed_id = u.id)
WHERE follower_id = 3
  EXCEPT
SELECT u.* FROM users u JOIN followers f ON (f.follower_id = u.id)
WHERE followed_id = 3;